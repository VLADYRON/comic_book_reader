<!DOCTYPE html>

<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<title>Comic Book Reader</title>
		<style>
#mainPanel {
	padding: 0;
	margin: 0;
	background: rgba(0, 0, 0, 0.0);
	height: 100%;
	width: 100%;
	text-align: center;
	font: 100px/300px Helvetica, Arial, sans-serif;
	text-shadow: 4px 4px 20px white;
	opacity: 0.5;
	position: fixed;
}

#topPanel {
	opacity: 0.8;
	border: 1px solid black;
	margin: 20px;
	margin-top: 0px;
	padding: 20px;
	padding-top: 0px;
	box-shadow: 10px 10px 5px #888888;
	background: silver;
	text-align: center;
}

#loadProgress {
	width: 100%;
	display: none;
}

#btnFullScreen {
	font: 30px/100px Helvetica, Arial, sans-serif;
}

#fileInput {
	display: none;
}

#fileLoad {
	font: 30px/100px Helvetica, Arial, sans-serif;
}

#pageHolder {
	pointer-events: none;
	width: 100%;
	position: absolute;
	top: 0;
	left: 0;
	z-index: -100;
}
		</style>
		<script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
		<script src="js/polyfill/polyfill.js"></script>
		<script src="https://hammerjs.github.io/dist/hammer.js"></script>
		<script src="js/zip.js"></script>
		<script src="js/screenfull.js/screenfull.js"></script>
	</head>
	<body style="margin: 0; padding: 0;">
		<div id="topPanel">
			<input id="fileInput" type="file" required="required" />
			<button id="fileLoad">Load comic from your computer</button>

			<button id="btnFullScreen">Full Screen</button>

			<progress id="loadProgress" max="1" value="0"></progress>
			<p><span id="loadError"></span></p>
			<div id="comicData">
				<b>Name:</b> <span id="nameValue"></span><br>
				<b>Size:</b> <span id="sizeValue"></span><br>
				<b>Type:</b> <span id="typeValue"></span><br>
			</div>
		</div>

		<div id="mainPanel"></div>

		<div id="pageHolder"></div>

		<script>

var g_entries = [];
var g_images = [];
var g_image_index = 0;

function toFrieldlySize(size) {
	if (size >= 1024000000) {
		return (size / 1024000000).toFixed(2) + ' GB';
	} else if (size >= 1024000) {
		return (size / 1024000).toFixed(2) + ' MB';
	} else if (size >= 1024) {
		return (size / 1024).toFixed(2) + ' KB';
	} else if (size >= 1) {
		return (size / 1).toFixed(2) + ' B';
	}

	return '?';
}

function blobToDataURI(blob, cb) {
	var a = new FileReader();
	a.onload = function(e) {
		cb(e.target.result);
	};
	a.readAsDataURL(blob);
}

function isValidImageType(file_name) {
	file_name = file_name.toLowerCase();
	return file_name.endsWith('.jpeg') || 
			file_name.endsWith('.jpg') ||
			file_name.endsWith('.png') || 
			file_name.endsWith('.bmp');
}

function loadComic() {
	var file_input = $('#fileInput');

	// Just return if there is no file selected
	if (file_input[0].files.length === 0) {
		return;
	}

	// Load the file's info
	clearComicData();
	var file = file_input[0].files[0];
	setComicData(file.name, file.size, file.type);

	// Read the file
	var reader = new FileReader();
	reader.onload = function(e) {
		onProgress(1, 1);
		$('#loadProgress').hide();
		$('#topPanel').hide();
		$('#mainPanel').show();

		var blob = new Blob([e.target.result], {type : 'application/zip'});
		onLoaded(blob);
	};
	reader.onerror = function(e) {
		onError(e.target.error.name);
	};
	reader.onprogress = function(e) {
		onProgress(e.loaded, e.total);
	};
	reader.readAsArrayBuffer(file);
}

function friendlyPageNumber() {
	return 'Page ' + (g_image_index + 1) + ' of ' + g_images.length;
}

function loadCurrentPage() {
	// Load the current page
	updatePageCache(g_image_index);
	$('#pageHolder').empty();
	$('#pageHolder').append(g_images[g_image_index]);
	$('#mainPanel')[0].textContent = friendlyPageNumber();

	// Cache the next image
	delayedUpdateNextPageCache(g_image_index, 2);

	// Cache the previous image
	delayedUpdatePreviousPageCache(g_image_index, 2);
}

function delayedUpdateNextPageCache(index, depth) {
	if (index < g_images.length - 1) {
		index++;
		setTimeout(function() {
			if (depth > 0) {
				depth--;
				delayedUpdateNextPageCache(index, depth);
			}
			updatePageCache(index);
		}, 333);
	}
}

function delayedUpdatePreviousPageCache(index, depth) {
	if (index > 0) {
		index--;
		setTimeout(function() {
			if (depth > 0) {
				depth--;
				delayedUpdatePreviousPageCache(index, depth);
			}
			updatePageCache(index);
		}, 333);
	}
}

function updatePageCache(index) {
	var img = g_images[index];
	if (img.is_loaded) {
		console.info('!!! Cached page: ' + index + ', ' + img.title);
	} else {
		var entry = g_entries[index];
		entry.getData(new zip.BlobWriter(), function(blob) {
	//		console.info(entry.filename);
	//		console.info(blob);
			blobToDataURI(blob, function(data_uri) {
				// Load the blob into an image
				var img = g_images[entry.index];
				img.src = data_uri;
				img.is_loaded = true;
				console.info('Loaded page: ' + index + ', ' + img.title);
			});
		});
	}
}

function setComicData(name, size, type) {
	$('#comicData').show();
	$('#nameValue').text(name);
	$('#sizeValue').text(toFrieldlySize(size));
	$('#typeValue').text(type);
}

function clearComicData() {
	// Reset the UI
	$('#loadError').hide();
	$('#comicData').hide();
	$('#loadProgress').val(0);
	setComicData('?', '?', '?');

	// Remove all the old images
	$('#pageHolder').empty();
	g_image_index = 0;
	if (g_images.length > 0) {
		for (var i=0; i<g_images.length; ++i) {
			delete g_images[i];
		}
	}
	delete g_images;
	g_images = [];

	// Remove all the old entries
	delete g_entries;
	g_entries = [];
}

function onLoaded(blob) {
	var reader = new zip.BlobReader(blob);
	zip.createReader(reader, function(reader) {
		reader.getEntries(function(entries) {
			// Get only the entries that are valid images
			g_entries = [];
			entries.forEach(function(entry) {
				if (! entry.directory && isValidImageType(entry.filename)) {
					g_entries.push(entry);
				}
			});

			// Sort the entries by their file names
			g_entries.sort(function(a, b){
				if(a.filename < b.filename) return -1;
				if(a.filename > b.filename) return 1;
				return 0;
			});

			// Create empty images for each page
			var i = 0;
			g_entries.forEach(function(entry) {
				var img = document.createElement('img');
				img.title = entry.filename;
	//			img.width = 100;
				img.style.width = '100%';
				g_images.push(img);
				entry.index = i;
				i++;
			});

			g_image_index = 0;
			loadCurrentPage();
		});
	}, function(e) {
		onError('Failed to read file!');
	});
}

function onError(msg) {
	$('#comicData').hide();
	$('#loadError').text('Error: ' + msg);
	$('#loadError').show();
}

function onProgress(loaded, total) {
	$('#loadProgress').show();
	$('#loadProgress').val(loaded / total);
}

$(document).ready(function() {
	// Tell zip.js where it can find the worker js file
	zip.workerScriptsPath = 'js/';

	// Stop the right click menu from popping up
	$(document).on('contextmenu', function(e) {
		e.preventDefault();
	});

	// Toggle full screen
	$('#btnFullScreen').click(function () {
		if (screenfull.enabled) {
			screenfull.toggle();
		}
	});

	// Tell Hammer to use the main pannel
	$('#mainPanel').hide();
	var mc = new Hammer($('#mainPanel')[0]);

	// Have gestures work in all directions
	mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });

	// Show the file load menu when panning down
	mc.on('pandown', function(ev) {
		$('#topPanel').show();
	});

	// Hide the file load menu when panning up
	mc.on('panup', function(ev) {
		$('#topPanel').hide();
	});

	// Show the next page when panning left
	mc.on('panleft tap', function(ev) {
		if ($('#topPanel').is(':visible')) {
			$('#topPanel').hide();
		} else {
			if (g_image_index < g_images.length -1) {
				g_image_index++;
				loadCurrentPage();
			}
		}
	});

	// Show the previous page when panning right
	mc.on('panright press', function(ev) {
		if ($('#topPanel').is(':visible')) {
			$('#topPanel').hide();
		} else {
			if (g_image_index > 0) {
				g_image_index--;
				loadCurrentPage();
			}
		}
	});

	// When a file is selected, load it
	$('#fileInput').change(function(e) {
		loadComic();
	});

	// When the button is clicked, click the hidden file load button
	$('#fileLoad').click(function(e) {
		$('#fileInput').click();
	});
	clearComicData();
});
		</script>
	</body>

</html>
